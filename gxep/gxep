#!/usr/bin/env python3
# coding: utf-8
#

import re, os, argparse, time
from lxml import html, etree

parser = argparse.ArgumentParser(argument_default=False, description="%(prog)s searches for PATTERN in each FILE. A FILE of “-” stands for standard input. If no FILE is given, recursive searches examine the working directory, and nonrecursive searches read standard input. By default, %(prog)s prints the matching lines.")

requiredArguments = parser.add_argument_group("Required")
parserGroup_query = requiredArguments.add_mutually_exclusive_group(required=True)
#type=argparse.FileType('r', encoding="utf-8")
parserGroup_query.add_argument("-f", "--file", type=argparse.FileType('r', encoding='utf-8'), metavar="FILE", help="Obtain patterns from FILE, one per line. If this option is used multiple times, search for all patterns given. The empty file contains zero patterns, and therefore matches nothing.")
parserGroup_query.add_argument("-p", "--pattern", nargs='?', help="Obtain patterns from FILE, one per line. If this option is used multiple times, search for all patterns given. The empty file contains zero patterns, and therefore matches nothing.")
optionalArguments = parser.add_argument_group("Optionals")
parserGroup_type = optionalArguments.add_mutually_exclusive_group()
parserGroup_type.add_argument("-X", "--xml", action="store_true", default=True, help="Interpret FILE as XML document. This is the default.")
parserGroup_type.add_argument("-Y", "--html", action="store_true", help="Interpret FILE as HTML document.")
parserGroup_filematchInversion = optionalArguments.add_mutually_exclusive_group()
parserGroup_filematchInversion.add_argument("-L", "--files-without-match", action="store_true", help="Suppress normal output; instead print the name of each input file from which no output would normally have been printed. The scanning will stop on the first match.")
parserGroup_filematchInversion.add_argument("-l", "--files-with-matches", action="store_true", help="Suppress normal output; instead print the name of each input file from which output would normally have been printed. The scanning will stop on the first match.")
parserGroup_recursion = optionalArguments.add_mutually_exclusive_group()
parserGroup_recursion.add_argument("-r", "--recursive", action="store_true", help="Read all files under each directory, recursively, following symbolic links only if they are on the command line. Note that if no file operand is given, %(prog)s searches the working directory.")
parserGroup_recursion.add_argument("-R", "--dereference-recursive", action="store_true", help="Read all files under each directory, recursively. Follow all symbolic links, unlike -r.")
parser.add_argument("checkpath", nargs='?', help="The file or files to check against the given XPaths. Expects directory by default.")
args = parser.parse_args()

root_path = os.path.expanduser(args.checkpath)

if not os.path.exists(root_path):
	parser.error("{}: No such file or directory".format(args.checkpath))

if os.path.isfile(root_path):
	directory_walker = [("", [], [root_path])]
elif os.path.isdir(root_path):
	if args.recursive or args.dereference_recursive:
		directory_walker = os.walk(top=root_path, followlinks=args.dereference_recursive)
	else:
		parser.error("{}: Is a directory".format(root_path))
else:
	parser.exit("TODO: Read from STDIN")

try:
	for walk_tuple in directory_walker:
		for raw_filename in walk_tuple[2]:
			this_filename = os.path.join(walk_tuple[0], raw_filename)
			with open(this_filename, encoding="utf-8") as this_file:
				if args.html:
					tree = html.fromstring(this_file.read())
				else:
					tree = etree.fromstring(this_file.read())
				xpath_match = tree.xpath(args.PATTERN)
				if len(xpath_match) == 0 and args.files_without_match:
					print(this_filename)
				elif len(xpath_match) != 0 and not args.files_without_match:
					if args.files_with_matches:
						print(this_filename)
					else:
						for result in xpath_match:
							print("{filename}:{match}".format(filename=this_filename, match=result))
except KeyboardInterrupt as e:
	exit("")
